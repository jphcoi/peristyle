'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = iteration;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _take = require('obliterator/take');

var _take2 = _interopRequireDefault(_take);

var _nodes = require('./nodes');

var _nodes2 = _interopRequireDefault(_nodes);

var _edges = require('./edges');

var _edges2 = _interopRequireDefault(_edges);

var _neighbors = require('./neighbors');

var _neighbors2 = _interopRequireDefault(_neighbors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function iteration(Graph, checkers) {
  return {
    Adjacency: {

      'it should be possible to iterate over the graph\'s adjacency using callbacks.': function itShouldBePossibleToIterateOverTheGraphSAdjacencyUsingCallbacks() {
        var graph = new Graph();

        graph.mergeEdge(1, 2);
        graph.mergeEdge(2, 3);
        graph.mergeEdge(3, 1);

        graph.replaceNodeAttributes(2, { hello: 'world' });

        var adjacency = [];

        graph.forEach(function (s, t, sa, ta, e, ea) {
          adjacency.push([s, t]);
          _assert2.default.deepEqual(sa, graph.getNodeAttributes(s));
          _assert2.default.deepEqual(ta, graph.getNodeAttributes(t));
          _assert2.default.deepEqual(ea, graph.getEdgeAttributes(e));
        });

        _assert2.default.deepEqual(adjacency, [[1, 2], [2, 3], [3, 1]]);
      },

      'it should be possible to create an iterator over the graph\'s adjacency.': function itShouldBePossibleToCreateAnIteratorOverTheGraphSAdjacency() {
        var graph = new Graph();

        graph.mergeEdge(1, 2);
        graph.mergeEdge(2, 3);
        graph.mergeEdge(3, 1);

        graph.replaceNodeAttributes(2, { hello: 'world' });

        _assert2.default.deepEqual((0, _take2.default)(graph.adjacency()), graph.edges().map(function (edge) {
          var _graph$extremities = graph.extremities(edge),
              source = _graph$extremities[0],
              target = _graph$extremities[1];

          return [source, target, graph.getNodeAttributes(source), graph.getNodeAttributes(target), edge, graph.getEdgeAttributes(edge)];
        }));
      },

      'it should be possible to iterate via Symbol.iterator.': function itShouldBePossibleToIterateViaSymbolIterator() {
        if (typeof Symbol === 'undefined') return;

        var graph = new Graph();

        graph.mergeEdge(1, 2);
        graph.mergeEdge(2, 3);
        graph.mergeEdge(3, 1);

        graph.replaceNodeAttributes(2, { hello: 'world' });

        _assert2.default.deepEqual((0, _take2.default)(graph[Symbol.iterator]()), graph.edges().map(function (edge) {
          var _graph$extremities2 = graph.extremities(edge),
              source = _graph$extremities2[0],
              target = _graph$extremities2[1];

          return [source, target, graph.getNodeAttributes(source), graph.getNodeAttributes(target), edge, graph.getEdgeAttributes(edge)];
        }));
      }
    },
    Nodes: (0, _nodes2.default)(Graph, checkers),
    Edges: (0, _edges2.default)(Graph, checkers),
    Neighbors: (0, _neighbors2.default)(Graph, checkers)
  };
} /**
   * Graphology Iteration Specs
   * ===========================
   *
   * Testing the iteration-related methods of the graph.
   */