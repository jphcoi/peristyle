'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = properties;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PROPERTIES = ['order', 'size', 'directedSize', 'undirectedSize', 'type', 'multi', 'allowSelfLoops']; /**
                                                                                                          * Graphology Properties Specs
                                                                                                          * ============================
                                                                                                          *
                                                                                                          * Testing the properties of the graph.
                                                                                                          */
function properties(Graph) {

  return {

    /**
     * Regarding all properties.
     */
    'misc': {

      'all expected properties should be set.': function allExpectedPropertiesShouldBeSet() {
        var graph = new Graph();

        PROPERTIES.forEach(function (property) {
          (0, _assert2.default)(property in graph, property);
        });
      },

      'properties should be read-only.': function propertiesShouldBeReadOnly() {
        var graph = new Graph();

        // Attempting to mutate the properties
        PROPERTIES.forEach(function (property) {
          _assert2.default.throws(function () {
            graph[property] = 'test';
          }, TypeError);
        });
      }
    },

    /**
     * Order.
     */
    '#.order': {

      'it should be 0 if the graph is empty.': function itShouldBe0IfTheGraphIsEmpty() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.order, 0);
      },

      'adding nodes should increase order.': function addingNodesShouldIncreaseOrder() {
        var graph = new Graph();
        graph.addNode('John');
        graph.addNode('Jack');
        _assert2.default.strictEqual(graph.order, 2);
      }
    },

    /**
     * Size.
     */
    '#.size': {

      'it should be 0 if the graph is empty.': function itShouldBe0IfTheGraphIsEmpty() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.size, 0);
      },

      'adding & dropping edges should affect size.': function addingDroppingEdgesShouldAffectSize() {
        var graph = new Graph();
        graph.addNode('John');
        graph.addNode('Jack');
        graph.addDirectedEdge('John', 'Jack');
        _assert2.default.strictEqual(graph.size, 1);

        graph.dropEdge('John', 'Jack');
        _assert2.default.strictEqual(graph.size, 0);
      }
    },

    /**
     * Directed Size.
     */
    '#.directedSize': {

      'it should be 0 if the graph is empty.': function itShouldBe0IfTheGraphIsEmpty() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.directedSize, 0);
      },

      'adding & dropping edges should affect directed size.': function addingDroppingEdgesShouldAffectDirectedSize() {
        var graph = new Graph();
        graph.addNode('John');
        graph.addNode('Jack');

        var directedEdge = graph.addDirectedEdge('John', 'Jack');
        _assert2.default.strictEqual(graph.directedSize, 1);

        var undirectedEdge = graph.addUndirectedEdge('John', 'Jack');
        _assert2.default.strictEqual(graph.directedSize, 1);

        graph.dropEdge(directedEdge);
        _assert2.default.strictEqual(graph.directedSize, 0);

        graph.dropEdge(undirectedEdge);
        _assert2.default.strictEqual(graph.directedSize, 0);
      }
    },

    /**
     * Undirected Size.
     */
    '#.undirectedSize': {

      'it should be 0 if the graph is empty.': function itShouldBe0IfTheGraphIsEmpty() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.undirectedSize, 0);
      },

      'adding & dropping edges should affect undirected size.': function addingDroppingEdgesShouldAffectUndirectedSize() {
        var graph = new Graph();
        graph.addNode('John');
        graph.addNode('Jack');

        var directedEdge = graph.addDirectedEdge('John', 'Jack');
        _assert2.default.strictEqual(graph.undirectedSize, 0);

        var undirectedEdge = graph.addUndirectedEdge('John', 'Jack');
        _assert2.default.strictEqual(graph.undirectedSize, 1);

        graph.dropEdge(directedEdge);
        _assert2.default.strictEqual(graph.undirectedSize, 1);

        graph.dropEdge(undirectedEdge);
        _assert2.default.strictEqual(graph.undirectedSize, 0);
      }
    },

    /**
     * Multi.
     */
    '#.multi': {

      'it should be false by default.': function itShouldBeFalseByDefault() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.multi, false);
      }
    },

    /**
     * Type.
     */
    '#.type': {

      'it should be "mixed" by default.': function itShouldBeMixedByDefault() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.type, 'mixed');
      }
    },

    /**
     * Self loops.
     */
    '#.allowSelfLoops': {

      'it should be true by default.': function itShouldBeTrueByDefault() {
        var graph = new Graph();
        _assert2.default.strictEqual(graph.allowSelfLoops, true);
      }
    }
  };
}