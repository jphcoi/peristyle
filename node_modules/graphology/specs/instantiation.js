'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = instantiation;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-unused-vars: 0 */
/**
 * Graphology Instantiation Specs
 * ===============================
 *
 * Testing the instantiation of the graph.
 */
var CONSTRUCTORS = ['DirectedGraph', 'UndirectedGraph', 'MultiDirectedGraph', 'MultiUndirectedGraph'];

var OPTIONS = [{ multi: false, type: 'directed' }, { multi: false, type: 'undirected' }, { multi: true, type: 'directed' }, { multi: true, type: 'undirected' }];

function instantiation(Graph, implementation, checkers) {
  var invalid = checkers.invalid;


  return {
    'Static #.from method': {

      'it should be possible to create a Graph from a Graph instance.': function itShouldBePossibleToCreateAGraphFromAGraphInstance() {
        var graph = new Graph();
        graph.addNodesFrom(['John', 'Thomas']);
        graph.addEdge('John', 'Thomas');

        var other = Graph.from(graph);

        _assert2.default.deepEqual(graph.nodes(), other.nodes());
        _assert2.default.deepEqual(graph.edges(), other.edges());
      },

      'it should be possible to create a Graph from a serialized graph': function itShouldBePossibleToCreateAGraphFromASerializedGraph() {
        var graph = Graph.from({
          nodes: [{ key: 'John' }, { key: 'Thomas' }],
          edges: [{ source: 'John', target: 'Thomas' }]
        });

        _assert2.default.deepEqual(graph.nodes(), ['John', 'Thomas']);
        _assert2.default.strictEqual(graph.hasEdge('John', 'Thomas'), true);
      },

      'it should be possible to provide options.': function itShouldBePossibleToProvideOptions() {
        var graph = Graph.from({
          node: [{ key: 'John' }],
          attributes: {
            name: 'Awesome graph'
          }
        }, { type: 'directed' });

        _assert2.default.strictEqual(graph.type, 'directed');
        _assert2.default.strictEqual(graph.getAttribute('name'), 'Awesome graph');
      }
    },

    'Options': {

      /**
       * allowSelfLoops
       */
      'allowSelfLoops': {

        'providing a non-boolean value should throw.': function providingANonBooleanValueShouldThrow() {
          _assert2.default.throws(function () {
            var graph = new Graph({ allowSelfLoops: 'test' });
          }, invalid());
        }
      },

      /**
       * edgeKeyGenerator
       */
      'edgeKeyGenerator': {

        'providing something other than a function should throw.': function providingSomethingOtherThanAFunctionShouldThrow() {
          _assert2.default.throws(function () {
            var graph = new Graph({ edgeKeyGenerator: 'test' });
          }, invalid());
        },

        'it should correctly give the edge an id.': function itShouldCorrectlyGiveTheEdgeAnId() {
          var edgeKeyGenerator = function edgeKeyGenerator(_ref) {
            var source = _ref.source,
                target = _ref.target;

            return source + '->' + target;
          };

          var graph = new Graph({ edgeKeyGenerator: edgeKeyGenerator });
          graph.addNodesFrom(['John', 'Martha', 'Clark']);
          graph.addEdge('John', 'Martha');
          graph.addEdge('Martha', 'Clark');

          _assert2.default.deepEqual(graph.edges(), ['John->Martha', 'Martha->Clark']);
        }
      },

      /**
       * multi
       */
      'multi': {

        'providing a non-boolean value should throw.': function providingANonBooleanValueShouldThrow() {
          _assert2.default.throws(function () {
            var graph = new Graph({ multi: 'test' });
          }, invalid());
        }
      },

      /**
       * type
       */
      'type': {

        'providing an invalid type should throw.': function providingAnInvalidTypeShouldThrow() {
          _assert2.default.throws(function () {
            var graph = new Graph({ type: 'test' });
          }, invalid());
        }
      }
    },

    'Constructors': {

      'all alternative constructors should be available.': function allAlternativeConstructorsShouldBeAvailable() {
        CONSTRUCTORS.forEach(function (name) {
          return (0, _assert2.default)(name in implementation);
        });
      },

      'alternative constructors should have the correct options.': function alternativeConstructorsShouldHaveTheCorrectOptions() {
        CONSTRUCTORS.forEach(function (name, index) {
          var graph = new implementation[name]();

          var _OPTIONS$index = OPTIONS[index],
              multi = _OPTIONS$index.multi,
              type = _OPTIONS$index.type;


          _assert2.default.strictEqual(graph.multi, multi);
          _assert2.default.strictEqual(graph.type, type);
        });
      }
    }
  };
}