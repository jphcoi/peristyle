'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = utils;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PROPERTIES = ['type', 'multi', 'map', 'selfLoops']; /**
                                                         * Graphology Utils Specs
                                                         * =======================
                                                         *
                                                         * Testing the utils methods.
                                                         */
function utils(Graph) {
  return {
    '#.emptyCopy': {
      'it should create an empty copy of the graph.': function itShouldCreateAnEmptyCopyOfTheGraph() {
        var graph = new Graph();
        graph.addNodesFrom(['John', 'Thomas']);
        graph.addEdge('John', 'Thomas');

        var copy = graph.emptyCopy();

        _assert2.default.deepEqual(copy.nodes(), []);
        _assert2.default.strictEqual(copy.order, 0);
        _assert2.default.strictEqual(copy.size, 0);

        PROPERTIES.forEach(function (property) {
          _assert2.default.strictEqual(graph[property], copy[property]);
        });
      }
    },

    '#.copy': {
      'it should create a full copy of the graph.': function itShouldCreateAFullCopyOfTheGraph() {
        var graph = new Graph();
        graph.addNodesFrom(['John', 'Thomas']);
        graph.addEdge('John', 'Thomas');

        var copy = graph.copy();

        _assert2.default.deepEqual(copy.nodes(), graph.nodes());
        _assert2.default.deepEqual(copy.edges(), graph.edges());
        _assert2.default.strictEqual(copy.order, 2);
        _assert2.default.strictEqual(copy.size, 1);

        PROPERTIES.forEach(function (property) {
          _assert2.default.strictEqual(graph[property], graph[property]);
        });
      }
    },

    '#.upgradeToMixed': {
      'it should correctly upgrade the given graph to a mixed one.': function itShouldCorrectlyUpgradeTheGivenGraphToAMixedOne() {
        var graph = new Graph({ type: 'directed' });
        graph.addNodesFrom([1, 2, 3]);
        graph.addEdgeWithKey('1->2', 1, 2);

        graph.upgradeToMixed();

        _assert2.default.strictEqual(graph.type, 'mixed');

        graph.addUndirectedEdge(2, 3);

        _assert2.default.strictEqual(graph.size, 2);
        _assert2.default.strictEqual(graph.degree(2), 2);
      }
    },

    '#.upgradeToMulti': {
      'it should correctly upgrade the given graph to a multi one.': function itShouldCorrectlyUpgradeTheGivenGraphToAMultiOne() {
        var graph = new Graph();
        graph.addNodesFrom([1, 2]);
        graph.addEdgeWithKey('dA', 1, 2);
        graph.addUndirectedEdgeWithKey('uA', 1, 2);

        graph.upgradeToMulti();

        _assert2.default.strictEqual(graph.multi, true);

        graph.addEdgeWithKey('dB', 1, 2);
        graph.addUndirectedEdgeWithKey('uB', 1, 2);

        _assert2.default.strictEqual(graph.size, 4);

        _assert2.default.deepEqual(graph.edges(), ['dA', 'uA', 'dB', 'uB']);
      }
    }
  };
}